#!/bin/bash
# Script de monitoreo de salud generado por Puppet
# <%= @timestamp %>

# Configuración
PLATFORM_DIR="/opt/platform/remote-execution-platform"
LOG_FILE="/opt/platform/logs/health-check.log"
ALERT_EMAIL="<%= @alert_email || 'admin@localhost' %>"

# Colores
GREEN='\033[0;32m'
RED='\033[0;31m'
YELLOW='\033[1;33m'
NC='\033[0m'

log() {
    echo -e "${GREEN}[$(date '+%Y-%m-%d %H:%M:%S')]${NC} $1" | tee -a "$LOG_FILE"
}

error() {
    echo -e "${RED}[$(date '+%Y-%m-%d %H:%M:%S')] ERROR:${NC} $1" | tee -a "$LOG_FILE"
}

warn() {
    echo -e "${YELLOW}[$(date '+%Y-%m-%d %H:%M:%S')] WARNING:${NC} $1" | tee -a "$LOG_FILE"
}

# Función para enviar alertas
send_alert() {
    local message="$1"
    local subject="[PLATFORM ALERT] $2"
    
    # Log local
    error "$message"
    
    # Enviar email si está configurado
    if command -v mail &> /dev/null && [ "$ALERT_EMAIL" != "admin@localhost" ]; then
        echo "$message" | mail -s "$subject" "$ALERT_EMAIL"
    fi
    
    # Enviar a syslog
    logger -p daemon.error -t platform-monitor "$message"
}

# Verificar servicios Docker
check_docker_services() {
    log "Verificando servicios Docker..."
    
    cd "$PLATFORM_DIR" || exit 1
    
    # Servicios críticos
    critical_services=("postgres" "redis" "backend" "nginx")
    
    for service in "${critical_services[@]}"; do
        if ! docker-compose ps "$service" | grep -q "Up"; then
            send_alert "Servicio crítico $service no está funcionando" "Service Down"
            return 1
        fi
    done
    
    log "Todos los servicios críticos están funcionando"
    return 0
}

# Verificar conectividad de base de datos
check_database() {
    log "Verificando conectividad de base de datos..."
    
    cd "$PLATFORM_DIR" || exit 1
    
    if docker-compose exec -T postgres pg_isready -U platform_user -d remote_execution &>/dev/null; then
        log "Base de datos accesible"
        return 0
    else
        send_alert "Base de datos PostgreSQL no responde" "Database Down"
        return 1
    fi
}

# Verificar Redis
check_redis() {
    log "Verificando Redis..."
    
    cd "$PLATFORM_DIR" || exit 1
    
    if docker-compose exec -T redis redis-cli ping | grep -q "PONG"; then
        log "Redis funcionando correctamente"
        return 0
    else
        send_alert "Redis no responde" "Redis Down"
        return 1
    fi
}

# Verificar API
check_api() {
    log "Verificando API..."
    
    if curl -f -s http://localhost:8000/health &>/dev/null; then
        log "API respondiendo correctamente"
        return 0
    else
        send_alert "API no responde en puerto 8000" "API Down"
        return 1
    fi
}

# Verificar frontend
check_frontend() {
    log "Verificando frontend..."
    
    if curl -f -s -k https://localhost/health &>/dev/null; then
        log "Frontend accesible"
        return 0
    else
        warn "Frontend no accesible (puede ser normal si no está configurado SSL)"
        return 1
    fi
}

# Verificar uso de recursos
check_resources() {
    log "Verificando uso de recursos..."
    
    # Verificar uso de disco
    disk_usage=$(df /opt/platform | tail -1 | awk '{print $5}' | sed 's/%//')
    if [ "$disk_usage" -gt 90 ]; then
        send_alert "Uso de disco crítico: ${disk_usage}%" "Disk Space Critical"
    elif [ "$disk_usage" -gt 80 ]; then
        warn "Uso de disco alto: ${disk_usage}%"
    fi
    
    # Verificar memoria
    mem_usage=$(free | grep Mem | awk '{printf "%.0f", $3/$2 * 100.0}')
    if [ "$mem_usage" -gt 90 ]; then
        send_alert "Uso de memoria crítico: ${mem_usage}%" "Memory Critical"
    elif [ "$mem_usage" -gt 80 ]; then
        warn "Uso de memoria alto: ${mem_usage}%"
    fi
    
    # Verificar carga del sistema
    load_avg=$(uptime | awk -F'load average:' '{print $2}' | awk '{print $1}' | sed 's/,//')
    cpu_cores=$(nproc)
    load_threshold=$(echo "$cpu_cores * 2" | bc -l)
    
    if (( $(echo "$load_avg > $load_threshold" | bc -l) )); then
        send_alert "Carga del sistema alta: $load_avg (cores: $cpu_cores)" "High Load"
    fi
    
    log "Recursos del sistema: Disco: ${disk_usage}%, Memoria: ${mem_usage}%, Carga: $load_avg"
}

# Verificar logs de errores
check_error_logs() {
    log "Verificando logs de errores..."
    
    # Buscar errores recientes en logs
    error_count=$(find /opt/platform/logs -name "*.log" -mmin -5 -exec grep -l "ERROR\|CRITICAL\|FATAL" {} \; 2>/dev/null | wc -l)
    
    if [ "$error_count" -gt 0 ]; then
        warn "Se encontraron $error_count archivos de log con errores recientes"
        
        # Mostrar algunos errores recientes
        find /opt/platform/logs -name "*.log" -mmin -5 -exec grep -H "ERROR\|CRITICAL\|FATAL" {} \; 2>/dev/null | tail -5 | while read -r line; do
            warn "Error reciente: $line"
        done
    fi
}

# Función principal
main() {
    log "=== Iniciando verificación de salud de la plataforma ==="
    
    local exit_code=0
    
    # Ejecutar todas las verificaciones
    check_docker_services || exit_code=1
    check_database || exit_code=1
    check_redis || exit_code=1
    check_api || exit_code=1
    check_frontend || true  # No crítico
    check_resources
    check_error_logs
    
    if [ $exit_code -eq 0 ]; then
        log "=== Verificación completada: Sistema saludable ==="
    else
        error "=== Verificación completada: Se encontraron problemas ==="
    fi
    
    log "=== Fin de verificación ==="
    echo "" >> "$LOG_FILE"
    
    return $exit_code
}

# Ejecutar verificación
main "$@"